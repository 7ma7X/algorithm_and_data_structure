# 集合の表現法

## 優先度付き待ち行列（priority queue）

- 二分木
- 必ず 親 < 子
- 上の階層から詰め、一番下の階層では左から順に詰める
- 要素の追加、最小要素の取り出しがともに O(log n) でできる

**要素の追加**

最後尾につけて、親との大小関係の逆転が無くなるまで入れ替える。

**最小要素の削除**

根にあるのが最小値なのでまずこれを取り出す。  
空いた根の部分に最後尾の要素をもってきて、子との大小関係の逆転が無くなるまで入れ替える（入れ替える際、子が 2 つある場合は小さい方の子と交換する）。

## 2 分探索木（binary search tree）

- 必ず 左の子 < 親 < 右の子
- 操作は、理想的には完全な二分木となるので O(log n) でできる。最悪の場合には、木がひたすら一方へと偏るので O(n) になってしまう。
- 平均では O(log n) で抑えられる。

**要素の追加**

追加したい要素を、まず木の根と大小関係を比較して、それより小さければ今度は左側と、それより大きければ今度は右側と比較していく。これを再帰的に繰り返す。  
最終的に、空の葉が見つかったらそこに挿入する。

**要素の削除**

追加の場合と同様、木の根からスタートして再帰的に大小関係を比較し、もし等しい要素が見つかればそれを削除する。  
削除する葉について、子が左右ともに空の葉だったら何もしない。一方だけ空でなかったら、その一方を代わりに挿入する。  
左右ともに空でなかったら、(右の子の最小値, 右の子の最小値を削除した後の残り) を再帰的に計算し、それぞれ、削除した後の葉に挿入する要素、削除した後の右の子、と定める。

## 平衡木

2 分探索木は最悪の場合 O(n) になってしまう。そこで木の構造が変わる度にバランスをとるような操作を行い、最悪の場合の
計算量を抑えることができる。このような木を平衡木と呼ぶ。  

### 2-3 木

- 要素は全て末端の葉に格納、途中のノードは全てインデックス情報
- 途中ノードは必ず2つか3つの子を持つ
- インデックス情報であるノードは、子が2つの場合は2番目の子の子孫の最小値、子が3つの場合は2番目の子と3番目の子の子孫の最小値を持つ

**要素の追加**

2 分探索木と同様、追加したい要素を、まず木の根のインデックス情報と大小関係を比較して、再帰的に下へ降りていく。その後、追加によってもともと 3 つだった子が 4 つになった場合、新しい親を作って2つの子をその親へ移す。これを根の方へとさかのぼりながら再帰的に繰り返す。

**要素の削除**

追加の場合と同様、木の根からスタートして再帰的に大小関係を比較し、もし等しい要素が見つかればそれを削除する。  
削除によってもともと 2 つだった子が 1 つになった場合、隣の親が 3 つの子を持っていれば、そこから子を 1 つ移せる。隣の親がともに 2 つの子しか持っていない場合、 子をどちらかの親に移し、子のいなくなった親を削除する。これを根の方へとさかのぼりながら再帰的に繰り返す。もし根の子が1つになった場合、元の根を削除してそれを新しい根とする。

### AVL木

Coming soon...

## ハッシュ

これまでの順序関係を用いた集合の表現とは違い、単純な要素の参照、追加、削除をO(1)でできる。  
要素が格納されている場所を直接計算できるようにする。  
この際、すでにデータが格納されている可能性がある（**衝突**）ので、これをどう扱うかで2通り方法がある。

### チェイン法

データ格納セルにリストをつなげることで、同じハッシュ関数値を返す複数のデータを1つの場所に置ける。  
なるべくデータが一箇所に集中しないようにハッシュ関数を設計することが重要。

### 開番地法

衝突が起きた場合、**再ハッシュ関数**によって次の候補場所を計算する。  
要素を削除した際にdeletedというラベルをしまっておくことで、正しく参照される。

## 集合群

複数の集合の集まり（**集合群**）の取り扱い  

- 要素が与えられた時にどの集合に属しているかを返す（Find）
- 2つの集合を併合して1つの集合にまとめ上げる（Merge）

これを効率良く行いたい。同値問題などで有効。  
単純な方法としては、

- ポインタ（1回のFindでO(n)、MergeでO(1)）
- ID（1回のFindでO(n)、MergeでO(n)）

がある。なお、IDの場合、最初ばらばらだった要素をMergeによって一つにまとめあげる際には「必ず要素数の小さいものを大きいものへ併合する」という工夫でO(n logn)にまで抑えることができる。

<br>

効率の良い集合群の表現方法として、**親へ向かうポインタを持つ木**がある。この場合  
  
**Merge**  

Mergeされる方の木全体をMergeする方の根の下につける。手間はO(1)。必ず小さい方の木を大きい方の木に付けることで木の深さを抑えることができる。  

**Find**

親へ向かうポインタを辿って根の先にある集合のIDを調べれば良い。手間は木の深さに比例。  
Findが起きるたびに、「ポインタを辿る過程で経由した頂点を根の下へと付け替える」(**経路圧縮**)を行うことで高速になる。
