# 有向グラフ

## Dijkstra's Algorithm

最短経路問題で, 辺のコストが非負のときに使える.

計算量:  
全頂点を見る（外側のループ) ・・・(a)  
見てない頂点の中でコストが最も小さいものを探す・・・(b)  
コストの更新・・・(c)  

とすると, 通常の場合(a)にO(n), (b)(c)にO(n)で, 全体でO(n^2)  

ただ, (b)の処理を, 辺の集合をリストで管理しPriority Queueで効率化することができる. その場合, 辺の数をe, 頂点の数をnとすると,  
最小値の取り出しがn回, ヒープの位置の更新が最大e回行われ, 1回のPQueの操作がO(nlogn)なので, 全体でO((n+e)logn)になる.  
辺の数eが少ない疎なグラフでは有効.

## Warshall–Floyd Algorithm

すべての節点からすべての節点への最短経路を求める. O(n^3)  
疎なグラフにおいては, PQueを使ったダイクストラn回よりは遅い.  

## DAGの一列化

DAG（Directed Acyclic Graph, 有向非巡回グラフ）においては, 節点の数値の順序が辺の向きと一致するようにする操作（**一列化, トポロジカルソート**）が可能.  
具体的には, 深さ優先探索の帰りがけに番号を振ればよい.

## 強連結成分

有向グラフの部分グラフであって, その中の任意の節点間の行き来が可能であるものを**強連結成分**と呼ぶ.  
一列化した（番号を振った）後, 有向グラフの向きを全て逆向きにしたグラフに対して, 番号の大きいものから順に深さ優先探索を行う.

# 無向グラフ

**極大木**: 閉路を含まない部分木, 任意の節点から任意の節点までの経路が必ず存在  
**最小木**: 与えられた木の極大木のうち, 辺の合計コストが最も小さいもの  

## Prim's Algorithm

最小木を求めるアルゴリズム. 任意の1点から成る木からスタートし, 近い節点を見ていく.  
外側のループがO(n), 内側の更新がO(n), 全体でO(n^2)

## Kruskal's Algorithm

最小木を求めるアルゴリズム. 最初は各点それぞれが部分木であるとする. コストの最小の辺から順々に取り出していく（ただし閉路になってしまうものは飛ばす）. 取り出せる辺が無くなったら終了. 辺の管理はPQue, 木をまとめる作業は親へのポインンタを持つ木による集合群の表現を用いればよい. 計算量は辺の数をeとしてO(eloge)で, 疎なグラフにおいては Prim のものより効率が良い.
